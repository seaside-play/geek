[# 1 非模板语言特性](#-1-非模板语言特性)

[# 2 模板泛型语言特性](#-2-模板泛型语言特性)

[# 3 新的标准库组件](#-3-新的标准库组件)

[# 4 现有标准组件的扩展和修改](#-4-现有标准组件的扩展和修改)

[# 5 为专家设计的基础库设计的语言和库特性](#-5-为专家设计的基础库设计的语言和库特性)

[# 6 C++17的一些通用提示](#-6-C++17的一些通用提示)

# 1 非模板的新核心语言特性
## 1.1 结构化绑定

结构化绑定允许你用一个对象的元素或成员同时实例化多个实体，结构化绑定对于返回**结构体**或者**数组**的**函数**来说非常有用。

好处
1. 可以直接访问成员
2. 把值绑定到能体现语义的变量名上，可以使代码的可读性更强。

  如使用结构化绑定的情况下遍历 std::map<> 的元素，使用准确体现语义的变量名直接访问每个元素的 key 和 value 成员

    for (const auto& [key, val] : mymap) {
      std::cout << key << ": " << val << '\n';
    }
## 1.2 细说
### 1.2.1 绑定到一个匿名实体

  结构化绑定时引入的新变量名其实都指向这个匿名对象的成员/元素。u 和 v 仅仅是 ms 的一份本地拷贝的成员的别名，注意 u 和 v 并不是 e.i 和 e.s 的引用（而是它们的别名）。

    auto e = getStruct();
    aliasname u = e.i;
    aliasname v = e.s;

也就是说，结构化绑定绑定到了一个新的实体 e 上，而不是直接绑定到了返回值上。

匿名实体 e 同样遵循通常的**内存对齐规则**，结构化绑定的每一个变量都会根据相应成员的类型进行对齐。

### 1.2.2 使用修饰符

1. const auto&：就是对初始对象的引用，初始对象发生变化时，结构化对象跟着变。若时对函数返回值进行const &，则延长生命周期；
2. auto&: 当前结构化对象的修改，会间接修改原来的结构体对象；

### 1.2.3 修饰符并不是作用在结构化绑定引入的变量上

    const auto& [u, v] = ms;

这里，匿名实体被声明为 const 引用，而 u 和 v 分别是这个引用的成员 i 和 s 的别名。因此，对 ms 的成员的修改会影响到 u 和 v 的值。

  <u>一定要明确u和v是别名，真正修饰的是匿名实体。</u>

如果声明为非 const 引用，你甚至可以间接地修改用于初始化的对象的成员。

如果一个结构化绑定是引用类型，而且是对一个临时对象的引用，那么和往常一样，临时对象的生命周期会被延长到结构化绑定的生命周期。

4. 指明对齐时也是一样

    alignas(16) auto [u, v] = ms;
    // 对 齐 匿 名 实 体 ， 而 不 是 v

  这里，我们对齐了匿名实体而不是 u 和 v。这意味着 u 作为第一个成员会按照 16 字节对齐，但 v 不会。

**【充电】**

- 优化与硬件交互及向量化操作

现代计算机系统对数据在内存中的存放位置有一定的对齐要求。比如，对于某些处理器架构，访问特定类型的数据（像一些 SIMD（单指令多数据流）数据类型，如__m128类型，它常用于向量化编程，长度通常为 16 字节）在内存中按特定对齐方式存放时，能获得更高效的读写性能。一般来说，处理器按字长（比如常见的 32 位系统按 4 字节对齐、64 位系统按 8 字节对齐等）或者特定硬件要求的粒度来进行高效访问，而alignas(16)就是强制要求编译器将所修饰的对象按照 16 字节边界对齐。

    struct alignas(16) MyStruct {
        int num;
        char ch;
    };

    使用了alignas(16)后，编译器会确保这个结构体在内存中从 16 字节对齐的地址开始存放，并且结构体整体大小会是 16 字节的倍数。

    目的之一就是当后续要把这个结构体用于和一些要求 16 字节对齐的硬件指令或者特定优化场景（如向量化运算等）交互时，能正确高效地进行数据读写。


    alignas(16)是 C++ 中用于精细控制内存对齐的一个重要特性，有助于提升性能、保证与硬件及特定优化技术配合的正确性以及增强代码跨平台的稳定性等。

5. auto不会类型退化

    struct S {
    const char x[6];
    const char y[3];
    };

那么如下声明之后：

    S s1{};
    auto [a, b] = s1;
    // a 和 b 的 类 型 是 结 构 体 成 员 的 精 确 类 型

这里 a 的类型仍然是 const char[6]。再次强调，auto 关键字应用在匿名实体上，这里匿名实体整体并不会发生类型退化。这和用 auto 初始化新对象不同，如下代码中会发生类型退化：
    
    auto a2 = a;
    // a2 的 类 型 是 a 的 退 化 类 型

### 1.2.4 move语义



# 2 模板泛型语言特性
# 3 新的标准库组件
# 4 现有标准组件的扩展和修改
# 5 为专家设计的基础库设计的语言和库特性
# 6 C++17的一些通用提示